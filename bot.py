import os
import logging
import asyncio
from typing import Dict, Optional

# Environment variable management
from dotenv import load_dotenv

# Telegram and bot framework
from aiogram import Bot, Dispatcher, Router, types
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.filters import Command
from aiogram.client.default import DefaultBotProperties

# Database ORM
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime
from sqlalchemy.orm import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.sql import func

# Solana integration
from solana.rpc.async_api import AsyncClient
from solders.pubkey import Pubkey as PublicKey
from solders.keypair import Keypair

# Additional utilities
import logging.config
import uuid
from datetime import datetime, timedelta
import base58
from contextlib import asynccontextmanager

# Load environment variables
load_dotenv()

# Base configuration and logging setup
class Config:
    """Centralized configuration management with secure loading"""
    
    @staticmethod
    def get_env_variable(var_name: str, default: Optional[str] = None) -> str:
        """
        Safely retrieve environment variables
        
        :param var_name: Name of the environment variable
        :param default: Default value if variable is not set
        :return: Value of the environment variable
        """
        value = os.getenv(var_name, default)
        if value is None or value.strip() == "":
            raise ValueError(f"Critical environment variable {var_name} is not set!")
        return value.strip()
    
    # Core bot configuration
    TELEGRAM_BOT_TOKEN = get_env_variable('TELEGRAM_BOT_TOKEN')
    SOLANA_RPC_URL = get_env_variable('SOLANA_RPC_URL', 'https://api.mainnet-beta.solana.com')
    DATABASE_URL = get_env_variable('DATABASE_URL', 'sqlite:///solana_dex_bot.db')
    
    # Logging configuration
    LOGGING_CONFIG = {
        'version': 1,
        'disable_existing_loggers': False,
        'formatters': {
            'standard': {
                'format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                'encoding': 'utf-8'
            },
        },
        'handlers': {
            'console': {
                'class': 'logging.StreamHandler',
                'formatter': 'standard',
                'level': get_env_variable('LOG_LEVEL', 'INFO'),
                'stream': 'ext://sys.stdout'
            },
            'file': {
                'class': 'logging.FileHandler',
                'filename': 'bot.log',
                'formatter': 'standard',
                'level': 'ERROR',
                'encoding': 'utf-8'
            }
        },
        'loggers': {
            '': {
                'handlers': ['console', 'file'],
                'level': get_env_variable('LOG_LEVEL', 'INFO'),
                'propagate': True
            }
        }
    }

# Configure logging
logging.config.dictConfig(Config.LOGGING_CONFIG)
logger = logging.getLogger(__name__)

# Database Models
Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    
    id = Column(Integer, primary_key=True)
    telegram_id = Column(Integer, unique=True)
    solana_wallet = Column(String, unique=True)
    private_key = Column(String)
    referral_code = Column(String, unique=True)
    total_volume = Column(Float, default=0.0)
    created_at = Column(DateTime, server_default=func.now())
    last_activity = Column(DateTime)

class CopyTrader(Base):
    __tablename__ = 'copy_traders'
    
    id = Column(Integer, primary_key=True)
    wallet_address = Column(String, unique=True, nullable=False)
    success_rate = Column(Float, default=0)
    total_trades = Column(Integer, default=0)
    followers_count = Column(Integer, default=0)
    created_at = Column(DateTime, server_default=func.now())

class Trade(Base):
    __tablename__ = 'trades'
    
    id = Column(Integer, primary_key=True)
    trader_id = Column(Integer, nullable=False)
    token_address = Column(String, nullable=False)
    amount = Column(Float, nullable=False)
    trade_type = Column(String, nullable=False)
    timestamp = Column(DateTime, server_default=func.now())

class SolanaDEXBot:
    def __init__(self):
        """Initialize bot with secure configuration"""
        try:
            # Bot and Router initialization with timeout settings
            self.bot = Bot(
                token=Config.TELEGRAM_BOT_TOKEN,
                default=DefaultBotProperties(parse_mode="HTML")
            )
            
            # Set timeout for the bot's session
            self.bot.session.timeout = 30  # Changed from _session to session
            
            self.storage = MemoryStorage()
            self.dp = Dispatcher(storage=self.storage)
            self.router = Router()
            
            # Solana RPC Client with timeout
            self.solana_client = AsyncClient(
                Config.SOLANA_RPC_URL,
                timeout=30
            )
            
            # Database setup with async support
            self.engine = create_engine(
                Config.DATABASE_URL,
                echo=True,
                pool_pre_ping=True,
                pool_recycle=3600
            )
            Base.metadata.create_all(self.engine)
            self.Session = sessionmaker(
                bind=self.engine,
                expire_on_commit=False
            )
            
            # Register handlers
            self._register_handlers()
            self.dp.include_router(self.router)
            
            logger.info("Bot initialized successfully")
        
        except Exception as e:
            logger.error(f"Failed to initialize bot: {e}")
            raise
    
    def _register_handlers(self):
        """Register message and callback handlers"""
        # Command handlers
        self.router.message.register(self.cmd_start, Command("start"))
        self.router.message.register(self.import_wallet, Command("import_wallet"))
        self.router.message.register(self.list_top_traders, Command("top_traders"))
        self.router.message.register(self.follow_trader, Command("follow"))
        
        # Callback handlers
        self.router.callback_query.register(
            self.on_show_private_key,
            lambda c: c.data == "show_private_key"
        )
        self.router.callback_query.register(
            self.on_import_wallet_button,
            lambda c: c.data == "import_wallet"
        )
        self.router.callback_query.register(
            self.on_top_traders_button,
            lambda c: c.data == "top_traders"
        )
    
    async def show_main_menu(self, message: types.Message):
        """Display the main menu with inline buttons"""
        keyboard = types.InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    types.InlineKeyboardButton(
                        text="üîó –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á",
                        callback_data="show_private_key"
                    )
                ],
                [
                    types.InlineKeyboardButton(
                        text="üì• –ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ—à–µ–ª–µ–∫",
                        callback_data="import_wallet"
                    )
                ],
                [
                    types.InlineKeyboardButton(
                        text="üìä –¢–æ–ø —Ç—Ä–µ–π–¥–µ—Ä—ã",
                        callback_data="top_traders"
                    )
                ]
            ]
        )
        
        await message.answer(
            "ü§ñ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ DEX Trade Bot!\n\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=keyboard
        )

    async def cmd_start(self, message: types.Message):
        """Handle /start command - creates new wallet for user"""
        try:
            session = self.Session()
            try:
                user = session.query(User).filter(
                    User.telegram_id == message.from_user.id
                ).first()
                
                if user:
                    await self.show_main_menu(message)
                else:
                    # Generate new Solana wallet
                    new_keypair = Keypair()  # Creates a new random keypair by default
                    
                    # Create user with new wallet
                    user = User(
                        telegram_id=message.from_user.id,
                        solana_wallet=str(new_keypair.pubkey()),
                        private_key=base58.b58encode(bytes(new_keypair)).decode(),
                        referral_code=str(uuid.uuid4())[:8],
                        total_volume=0.0
                    )
                    session.add(user)
                    session.commit()
                    
                    await message.answer(
                        "üéâ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –î–ª—è –≤–∞—Å —Å–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π Solana –∫–æ—à–µ–ª–µ–∫:\n\n"
                        f"–ê–¥—Ä–µ—Å: <code>{str(new_keypair.pubkey())}</code>\n\n"
                        "‚ö†Ô∏è –í–ê–ñ–ù–û: –•—Ä–∞–Ω–∏—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ–º –º–µ—Å—Ç–µ!\n"
                        "–ù–∏–∫–æ–≥–¥–∞ –Ω–µ –¥–µ–ª–∏—Ç–µ—Å—å –∏–º –Ω–∏ —Å –∫–µ–º.\n"
                        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É ¬´–ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á¬ª —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –µ–≥–æ.",
                        parse_mode="HTML"
                    )
                    await self.show_main_menu(message)
                
                logger.info(f"Start command handled for user {message.from_user.id}")
                
            except Exception as e:
                session.rollback()
                raise e
            finally:
                session.close()
            
        except Exception as e:
            logger.error(f"Error handling start command: {e}")
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")

    async def connect_wallet(self, message: types.Message):
        """Connect Solana wallet"""
        try:
            # Extract wallet address
            parts = message.text.split()
            if len(parts) != 2:
                await message.answer(
                    "‚ùå Please provide a wallet address:\n"
                    "<code>/connect_wallet WALLET_ADDRESS</code>",
                    parse_mode="HTML"
                )
                return
            
            wallet_address = parts[1]
            
            # Validate Solana address format
            try:
                # Convert to bytes first if it's base58
                if len(wallet_address) == 44:  # Base58 encoded length
                    wallet_bytes = base58.b58decode(wallet_address)
                    public_key = PublicKey(wallet_bytes)
                else:
                    public_key = PublicKey(wallet_address)
            except Exception as e:
                logger.error(f"Invalid wallet address: {e}")
                await message.answer("‚ùå Invalid Solana wallet address")
                return
            
            # Database session
            session = self.Session()
            try:
                # Check if user already exists
                existing_user = session.query(User).filter(
                    User.telegram_id == message.from_user.id
                ).first()
                
                if existing_user:
                    existing_user.solana_wallet = str(public_key)
                    await message.answer(
                        f"‚úÖ Wallet updated successfully!\n"
                        f"Address: <code>{str(public_key)[:8]}...</code>",
                        parse_mode="HTML"
                    )
                    await self.show_main_menu(message)  # Show main menu after update
                else:
                    # Create user
                    user = User(
                        telegram_id=message.from_user.id,
                        solana_wallet=str(public_key),
                        referral_code=str(uuid.uuid4())[:8],
                        total_volume=0.0
                    )
                    session.add(user)
                    await message.answer(
                        f"‚úÖ Wallet connected successfully!\n"
                        f"Address: <code>{str(public_key)[:8]}...</code>",
                        parse_mode="HTML"
                    )
                    await self.show_main_menu(message)  # Show main menu after connection
                
                session.commit()
                logger.info(f"Wallet connected for user {message.from_user.id}")
                
            except Exception as e:
                session.rollback()
                raise e
            finally:
                session.close()
        
        except Exception as e:
            logger.error(f"Wallet connection error: {e}")
            await message.answer(
                "‚ùå Error connecting wallet. Please try again or contact support."
            )
    
    async def list_top_traders(self, message: types.Message):
        """List top traders"""
        session = self.Session()
        try:
            # Query top traders
            top_traders = session.query(CopyTrader).order_by(
                CopyTrader.success_rate.desc()
            ).limit(10)
            
            # Prepare response
            response = "üèÜ –¢–æ–ø —Ç—Ä–µ–π–¥–µ—Ä—ã:\n\n"
            for trader in top_traders:
                response += (
                    f"–ê–¥—Ä–µ—Å: {trader.wallet_address[:8]}...\n"
                    f"–£—Å–ø–µ—à–Ω–æ—Å—Ç—å: {trader.success_rate*100:.2f}%\n"
                    f"–°–¥–µ–ª–æ–∫: {trader.total_trades}\n"
                    f"–ü–æ–¥–ø–∏—Å—á–∏–∫–æ–≤: {trader.followers_count}\n\n"
                )
            
            await message.answer(response)
            logger.info("Top traders list retrieved")
        
        except Exception as e:
            logger.error(f"Error retrieving top traders: {e}")
            await message.answer("‚ùå Error retrieving top traders")
        finally:
            session.close()

    async def start(self):
        """Start the bot polling"""
        try:
            logger.info("Starting bot polling")
            await self.dp.start_polling(self.bot)
        
        except Exception as e:
            logger.error(f"Bot polling error: {e}")

    async def on_connect_wallet_button(self, callback_query: types.CallbackQuery):
        """Handle connect wallet button press"""
        await callback_query.answer()
        await callback_query.message.answer(
            "Please send your Solana wallet address using the command:\n"
            "<code>/connect_wallet WALLET_ADDRESS</code>"
        )

    async def on_top_traders_button(self, callback_query: types.CallbackQuery):
        """Handle top traders button press"""
        await callback_query.answer()
        await self.list_top_traders(callback_query.message)

    async def follow_trader(self, message: types.Message):
        """Follow a trader's transactions"""
        session = self.Session()
        try:
            trader_address = message.text.split()[1]
            PublicKey(trader_address)  # Validate address
            
            # Check if trader exists
            trader = session.query(CopyTrader).filter_by(wallet_address=trader_address).first()
            if not trader:
                trader = CopyTrader(wallet_address=trader_address)
                session.add(trader)
            
            trader.followers_count += 1
            session.commit()
            
            await message.answer(f"ÔøΩÔøΩÔøΩ Now following trader {trader_address[:8]}...")
            
        except Exception as e:
            session.rollback()
            logger.error(f"Error following trader: {e}")
            await message.answer("‚ùå Error following trader. Please check the address.")
        finally:
            session.close()

    async def on_show_private_key(self, callback_query: types.CallbackQuery):
        """Handle private key display request"""
        await callback_query.answer()
        
        session = self.Session()
        try:
            user = session.query(User).filter(
                User.telegram_id == callback_query.from_user.id
            ).first()
            
            if not user:
                await callback_query.message.answer(
                    "‚ùå –ö–æ—à–µ–ª–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è."
                )
                return
            
            # Send private key in private message
            await callback_query.message.answer(
                "üîê –í–∞—à –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á:\n\n"
                f"<code>{user.private_key}</code>\n\n"
                "‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï:\n"
                "1. –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –¥–µ–ª–∏—Ç–µ—Å—å —ç—Ç–∏–º –∫–ª—é—á–æ–º\n"
                "2. –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –µ–≥–æ –≤ –Ω–∞–¥–µ–∂–Ω–æ–º –º–µ—Å—Ç–µ\n"
                "3. –ü–æ—Ç–µ—Ä—è –∫–ª—é—á–∞ = –ø–æ—Ç–µ—Ä—è –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–æ—à–µ–ª—å–∫—É",
                parse_mode="HTML"
            )
            
        finally:
            session.close()

    async def on_import_wallet_button(self, callback_query: types.CallbackQuery):
        """Handle wallet import button"""
        await callback_query.answer()
        await callback_query.message.answer(
            "üì• –î–ª—è –∏–º–ø–æ—Ä—Ç–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∫–æ—à–µ–ª—å–∫–∞ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–º–∞–Ω–¥—É:\n"
            "<code>/import_wallet PRIVATE_KEY</code>\n\n"
            "‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï:\n"
            "1. –ò–º–ø–æ—Ä—Ç –Ω–æ–≤–æ–≥–æ –∫–æ—à–µ–ª—å–∫–∞ –∑–∞–º–µ–Ω–∏—Ç —Ç–µ–∫—É—â–∏–π\n"
            "2. –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á —Ç–µ–∫—É—â–µ–≥–æ –∫–æ—à–µ–ª—å–∫–∞, –µ—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫ –Ω–µ–º—É –¥–æ—Å—Ç—É–ø\n"
            "3. –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –¥–µ–ª–∏—Ç–µ—Å—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–º –∫–ª—é—á–æ–º",
            parse_mode="HTML"
        )

    async def import_wallet(self, message: types.Message):
        """Import existing wallet using private key"""
        try:
            # Delete message with private key for security
            await message.delete()
            
            parts = message.text.split()
            if len(parts) != 2:
                await message.answer(
                    "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á:\n"
                    "<code>/import_wallet PRIVATE_KEY</code>",
                    parse_mode="HTML"
                )
                return
            
            private_key = parts[1]
            
            try:
                # Validate private key and get public key
                secret_bytes = base58.b58decode(private_key)
                keypair = Keypair.from_bytes(secret_bytes)  # Use the full bytes
                public_key = str(keypair.pubkey())
                
            except Exception as e:
                logger.error(f"Invalid private key: {e}")
                await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞")
                return
            
            # Update database
            session = self.Session()
            try:
                user = session.query(User).filter(
                    User.telegram_id == message.from_user.id
                ).first()
                
                if user:
                    user.solana_wallet = public_key
                    user.private_key = private_key
                else:
                    user = User(
                        telegram_id=message.from_user.id,
                        solana_wallet=public_key,
                        private_key=private_key,
                        referral_code=str(uuid.uuid4())[:8],
                        total_volume=0.0
                    )
                    session.add(user)
                
                session.commit()
                
                await message.answer(
                    "‚úÖ –ö–æ—à–µ–ª–µ–∫ —É—Å–ø–µ—à–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω!\n"
                    f"–ê–¥—Ä–µ—Å: <code>{public_key[:8]}...</code>",
                    parse_mode="HTML"
                )
                await self.show_main_menu(message)
                
            except Exception as e:
                session.rollback()
                raise e
            finally:
                session.close()
                
        except Exception as e:
            logger.error(f"Wallet import error: {e}")
            await message.answer(
                "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ –∫–æ—à–µ–ª—å–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
            )

async def main():
    """Main async entry point"""
    try:
        bot = SolanaDEXBot()
        await bot.start()
    except Exception as e:
        logger.critical(f"Critical error starting bot: {e}")

if __name__ == '__main__':
    asyncio.run(main())